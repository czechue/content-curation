"""
Digest generator for Content Curation System.

Creates markdown digests from rated content items.
"""

from datetime import datetime
from jinja2 import Template

from ..models import ContentItem, Rating


DIGEST_TEMPLATE = """
{{ date }}

Status: Published

Tags: [[curated-content]] [[weekly-digest]]

# Curated Content Digest

**Period:** {{ week_start }} to {{ week_end }}
**Total items:** {{ total_count }} ({{ s_count }} S-tier, {{ a_count }} A-tier)

---

{% if s_tier %}
## S-Tier (Must Consume)

{% for item in s_tier %}
### [{{ item.title }}]({{ item.url }})

**Source:** {{ item.source_name }} | **Published:** {{ item.published_date_str }}{% if item.duration_minutes %} | **Duration:** {{ item.duration_minutes }}m{% endif %}

{{ item.rating_reasoning }}

---

{% endfor %}
{% endif %}

{% if a_tier %}
## A-Tier (High Value)

{% for item in a_tier %}
- **[{{ item.title }}]({{ item.url }})** - {{ item.source_name }}
  - {{ item.rating_reasoning[:200] }}...

{% endfor %}
{% endif %}

---

### Sources

{% for source in sources %}
- {{ source }}
{% endfor %}

### References

1. Generated by Content Curation System
2. Rated using Fabric's rate_content pattern
"""


def generate_digest(items: list[ContentItem], source_names: dict[int, str] | None = None) -> str:
    """
    Generate a markdown digest from content items.

    Args:
        items: List of rated content items (should be A/S-tier)
        source_names: Optional dict mapping source_id to source name

    Returns:
        Markdown string ready to write to Obsidian
    """
    # Get source names if not provided
    if source_names is None:
        from .. import db
        sources = db.get_sources(enabled_only=False)
        source_names = {s.id: s.name for s in sources}

    # Separate by tier
    s_tier = [i for i in items if i.rating == Rating.S]
    a_tier = [i for i in items if i.rating == Rating.A]

    # Prepare items with additional fields
    def prepare_item(item: ContentItem) -> dict:
        return {
            "title": item.title,
            "url": item.url,
            "source_name": source_names.get(item.source_id, "Unknown"),
            "published_date_str": item.published_date.strftime("%Y-%m-%d") if item.published_date else "Unknown",
            "duration_minutes": item.duration_minutes,
            "rating_reasoning": item.rating_reasoning or "No reasoning provided",
        }

    s_tier_prepared = [prepare_item(i) for i in s_tier]
    a_tier_prepared = [prepare_item(i) for i in a_tier]

    # Get unique sources
    unique_sources = sorted(set(source_names.get(i.source_id, "Unknown") for i in items))

    # Calculate date range
    now = datetime.now()
    week_start = min((i.published_date for i in items if i.published_date), default=now)
    week_end = max((i.published_date for i in items if i.published_date), default=now)

    # Render template
    template = Template(DIGEST_TEMPLATE)
    return template.render(
        date=now.strftime("%Y-%m-%d %H:%M"),
        week_start=week_start.strftime("%Y-%m-%d"),
        week_end=week_end.strftime("%Y-%m-%d"),
        total_count=len(items),
        s_count=len(s_tier),
        a_count=len(a_tier),
        s_tier=s_tier_prepared,
        a_tier=a_tier_prepared,
        sources=unique_sources,
    )
